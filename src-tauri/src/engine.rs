use std::collections::HashMap;
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};

use anyhow::{Context, Result};
use tauri::{AppHandle, Emitter};
use tokio::sync::Mutex;

use crate::types::AudioDevice;

use crate::audio::{AudioCapture, AudioPlayback, MicTest};
use crate::peer::PeerConn;
use crate::signaling;
use crate::types::*;

const DEFAULT_SIGNALING_URL: &str = "wss://entavi-signaling.avdo.workers.dev/ws";

/// Engine is the central orchestrator stored in Tauri managed state.
pub struct Engine {
    inner: Arc<Mutex<Option<EngineInner>>>,
    app: AppHandle,
    /// Persists across sessions — not inside EngineInner.
    selected_input_device: std::sync::Mutex<Option<String>>,
    signaling_url: std::sync::Mutex<Option<String>>,
    mic_test: std::sync::Mutex<Option<MicTest>>,
    noise_suppression: Arc<AtomicBool>,
}

struct EngineInner {
    peer_id: String,
    #[allow(dead_code)]
    peer_name: String,
    room_id: String,
    room_name: String,
    signal_tx: flume::Sender<SignalMessage>,
    peers: HashMap<String, Arc<PeerConn>>,
    capture: AudioCapture,
    playback: AudioPlayback,
    /// Channel for ICE candidates generated by any PeerConn
    ice_tx: flume::Sender<(String, SignalPayload)>,
    ice_rx: flume::Receiver<(String, SignalPayload)>,
    /// RTT measurements from signaling ping/pong
    rtt_rx: flume::Receiver<u64>,
    is_host: bool,
    room_locked: bool,
}

impl Engine {
    pub fn new(app: AppHandle) -> Self {
        Self {
            inner: Arc::new(Mutex::new(None)),
            app,
            selected_input_device: std::sync::Mutex::new(None),
            signaling_url: std::sync::Mutex::new(None),
            mic_test: std::sync::Mutex::new(None),
            noise_suppression: Arc::new(AtomicBool::new(true)),
        }
    }

    pub fn set_signaling_url(&self, url: Option<String>) {
        *self.signaling_url.lock().unwrap() = url;
    }

    /// Create a new room. Returns the room_id (6-char code).
    pub async fn create_room(&self, room_name: String, name: String, password: Option<String>) -> Result<String> {
        let room_id = uuid::Uuid::new_v4().to_string()[..6].to_string();
        self.join_room_inner(room_id.clone(), room_name, name, None, true)
            .await?;

        // If a password was provided at creation time, lock the room immediately
        if let Some(pw) = password {
            let guard = self.inner.lock().await;
            if let Some(inner) = guard.as_ref() {
                inner
                    .signal_tx
                    .send(SignalMessage::LockRoom { password: Some(pw) })
                    .map_err(|_| anyhow::anyhow!("Signal channel closed"))?;
            }
        }

        Ok(room_id)
    }

    /// Join an existing room by room_id.
    pub async fn join_room(
        &self,
        room_id: String,
        name: String,
        password: Option<String>,
    ) -> Result<()> {
        let room_name = format!("Room {room_id}");
        self.join_room_inner(room_id, room_name, name, password, false)
            .await
    }

    async fn join_room_inner(
        &self,
        room_id: String,
        room_name: String,
        name: String,
        password: Option<String>,
        create: bool,
    ) -> Result<()> {
        // Stop mic test if running
        self.stop_mic_test();

        // Clean up any existing session
        self.leave_room().await?;

        let peer_id = uuid::Uuid::new_v4().to_string();

        self.emit_state(CallState::Connecting);

        // Start audio capture and playback
        let device_name = self.selected_input_device.lock().unwrap().clone();
        let capture =
            AudioCapture::new(device_name, Arc::clone(&self.noise_suppression)).context("Failed to start audio capture")?;
        let playback = AudioPlayback::new().context("Failed to start audio playback")?;

        // Connect to signaling server (room_id is part of the URL path)
        let base_url = self.signaling_url.lock().unwrap().clone()
            .unwrap_or_else(|| DEFAULT_SIGNALING_URL.to_string());
        let ws_url = format!("{base_url}/{room_id}");
        let (signal_tx, signal_rx, rtt_rx) = signaling::connect(&ws_url)
            .await
            .context("Failed to connect to signaling server")?;

        // Send join message
        signal_tx
            .send(SignalMessage::Join {
                room_id: room_id.clone(),
                peer_id: peer_id.clone(),
                name: name.clone(),
                password,
                create,
            })
            .map_err(|_| anyhow::anyhow!("Failed to send join message"))?;

        // ICE candidate channel shared across all peer connections
        let (ice_tx, ice_rx) = flume::unbounded::<(String, SignalPayload)>();

        let inner = EngineInner {
            peer_id,
            peer_name: name,
            room_id: room_id.clone(),
            room_name: room_name.clone(),
            signal_tx: signal_tx.clone(),
            peers: HashMap::new(),
            capture,
            playback,
            ice_tx,
            ice_rx,
            rtt_rx,
            is_host: false,
            room_locked: false,
        };

        *self.inner.lock().await = Some(inner);

        // Start the engine event loop
        let engine_inner = Arc::clone(&self.inner);
        let app = self.app.clone();

        tokio::spawn(async move {
            if let Err(e) = engine_loop(engine_inner, signal_rx, signal_tx, app.clone()).await {
                tracing::error!("Engine loop error: {e}");
                let _ = app.emit(EVENT_ERROR, format!("{e}"));
            }
        });

        // For creates, we can show InRoom immediately (we know the room exists).
        // For joins, wait for the server's RoomJoined response before switching views.
        if create {
            self.emit_state(CallState::InRoom {
                room_id,
                room_name,
                is_host: false,
                locked: false,
            });
        }

        Ok(())
    }

    pub async fn leave_room(&self) -> Result<()> {
        let mut guard = self.inner.lock().await;
        if let Some(inner) = guard.take() {
            // Send leave signal
            let _ = inner.signal_tx.send(SignalMessage::Leave {
                room_id: inner.room_id.clone(),
                peer_id: inner.peer_id.clone(),
            });

            // Close all peer connections
            for (_, peer) in &inner.peers {
                peer.close().await;
            }

            self.emit_state(CallState::Idle);
        }
        Ok(())
    }

    pub async fn set_muted(&self, muted: bool) -> Result<()> {
        let guard = self.inner.lock().await;
        if let Some(inner) = guard.as_ref() {
            inner.capture.set_muted(muted);
            // Broadcast mute state to all peers via signaling
            let _ = inner.signal_tx.send(SignalMessage::MuteState { muted });
        }
        Ok(())
    }

    pub async fn kick_peer(&self, peer_id: String) -> Result<()> {
        let guard = self.inner.lock().await;
        if let Some(inner) = guard.as_ref() {
            if !inner.is_host {
                return Err(anyhow::anyhow!("Only the host can kick peers"));
            }
            inner
                .signal_tx
                .send(SignalMessage::Kick { peer_id })
                .map_err(|_| anyhow::anyhow!("Signal channel closed"))?;
        }
        Ok(())
    }

    pub async fn force_mute_peer(&self, peer_id: String) -> Result<()> {
        let guard = self.inner.lock().await;
        if let Some(inner) = guard.as_ref() {
            if !inner.is_host {
                return Err(anyhow::anyhow!("Only the host can force-mute peers"));
            }
            inner
                .signal_tx
                .send(SignalMessage::ForceMute { peer_id })
                .map_err(|_| anyhow::anyhow!("Signal channel closed"))?;
        }
        Ok(())
    }

    pub async fn lock_room(&self, password: Option<String>) -> Result<()> {
        let guard = self.inner.lock().await;
        if let Some(inner) = guard.as_ref() {
            if !inner.is_host {
                return Err(anyhow::anyhow!("Only the host can lock the room"));
            }
            inner
                .signal_tx
                .send(SignalMessage::LockRoom { password })
                .map_err(|_| anyhow::anyhow!("Signal channel closed"))?;
        }
        Ok(())
    }

    /// Store the preferred input device. If currently in a call, restart capture.
    pub async fn set_input_device(&self, name: Option<String>) -> Result<()> {
        {
            let mut dev = self.selected_input_device.lock().unwrap();
            *dev = name.clone();
        }

        // If we're in a call, restart the capture thread with the new device
        let mut guard = self.inner.lock().await;
        if let Some(inner) = guard.as_mut() {
            let new_capture =
                AudioCapture::new(name, Arc::clone(&self.noise_suppression)).context("Failed to restart audio capture")?;
            // Replace capture — old one is dropped, its thread exits when
            // the encoded_tx sender side is dropped (receiver gone).
            inner.capture = new_capture;
            tracing::info!("Restarted audio capture with new input device");
        }

        Ok(())
    }

    pub fn list_input_devices(&self) -> Vec<AudioDevice> {
        crate::audio::list_input_devices()
    }

    pub fn start_mic_test(&self) -> Result<()> {
        // Stop any existing test first
        self.stop_mic_test();
        let device_name = self.selected_input_device.lock().unwrap().clone();
        let test = MicTest::new(device_name, self.app.clone(), Arc::clone(&self.noise_suppression))?;
        *self.mic_test.lock().unwrap() = Some(test);
        Ok(())
    }

    pub fn set_noise_suppression(&self, enabled: bool) {
        self.noise_suppression.store(enabled, Ordering::Relaxed);
    }

    pub fn stop_mic_test(&self) {
        if let Some(test) = self.mic_test.lock().unwrap().take() {
            test.stop();
        }
    }

    fn emit_state(&self, state: CallState) {
        let _ = self.app.emit(EVENT_STATE_CHANGED, &state);
    }
}

/// Main engine event loop. Runs as a tokio task.
async fn engine_loop(
    engine: Arc<Mutex<Option<EngineInner>>>,
    signal_rx: flume::Receiver<SignalMessage>,
    signal_tx: flume::Sender<SignalMessage>,
    app: AppHandle,
) -> Result<()> {
    let mut va_counter: u32 = 0;

    loop {
        // Get encoded audio rx, ice_rx, and rtt_rx from inner (if still active)
        let (encoded_rx, ice_rx, rtt_rx) = {
            let guard = engine.lock().await;
            let Some(inner) = guard.as_ref() else {
                break; // Engine shut down
            };
            (inner.capture.encoded_rx.clone(), inner.ice_rx.clone(), inner.rtt_rx.clone())
        };

        tokio::select! {
            // ── Signaling message from server ──
            msg = signal_rx.recv_async() => {
                let Ok(msg) = msg else { break };
                handle_signal_message(&engine, &signal_tx, &app, msg).await?;
            }

            // ── Encoded audio from microphone ──
            frame = encoded_rx.recv_async() => {
                let Ok(frame) = frame else { break };
                let guard = engine.lock().await;
                if let Some(inner) = guard.as_ref() {
                    for (_, peer) in &inner.peers {
                        if let Err(e) = peer.send_audio(&frame).await {
                            tracing::warn!("Failed to send audio to {}: {e}", peer.peer_id);
                        }
                    }
                }
            }

            // ── ICE candidate from one of our peer connections ──
            ice = ice_rx.recv_async() => {
                let Ok((target_peer_id, payload)) = ice else { break };
                let _ = signal_tx.send(SignalMessage::Signal {
                    to: Some(target_peer_id),
                    from: None,
                    payload,
                });
            }

            // ── RTT measurement from signaling ping/pong ──
            rtt = rtt_rx.recv_async() => {
                if let Ok(rtt_ms) = rtt {
                    let _ = app.emit(EVENT_PING_UPDATE, rtt_ms);
                }
            }
        }

        // ── Mix decoded audio from all remote peers into playback ──
        {
            let mut guard = engine.lock().await;
            if let Some(inner) = guard.as_mut() {
                let mut mixed = vec![0.0f32; FRAME_SIZE];
                let mut has_audio = false;
                let mut speaking_peers: Vec<String> = Vec::new();

                for (peer_id, peer) in &inner.peers {
                    let mut peer_peak: f32 = 0.0;
                    let mut peer_has_audio = false;

                    while let Ok(frame) = peer.decoded_rx.try_recv() {
                        has_audio = true;
                        peer_has_audio = true;
                        for (i, sample) in frame.samples.iter().enumerate() {
                            peer_peak = peer_peak.max(sample.abs());
                            if i < mixed.len() {
                                mixed[i] += sample;
                            }
                        }
                    }

                    if peer_has_audio && peer_peak > 0.01 {
                        speaking_peers.push(peer_id.clone());
                    }
                }

                if has_audio {
                    // Clamp to [-1.0, 1.0]
                    for s in &mut mixed {
                        *s = s.clamp(-1.0, 1.0);
                    }
                    inner.playback.write(&mixed);
                }

                // Emit voice activity event every ~100ms (5 frames × 20ms)
                va_counter += 1;
                if va_counter >= 5 {
                    va_counter = 0;
                    let self_speaking = inner.capture.is_speaking();
                    let _ = app.emit(
                        EVENT_VOICE_ACTIVITY,
                        VoiceActivityEvent {
                            speaking: speaking_peers,
                            self_speaking,
                        },
                    );
                }
            }
        }
    }

    Ok(())
}

async fn handle_signal_message(
    engine: &Arc<Mutex<Option<EngineInner>>>,
    signal_tx: &flume::Sender<SignalMessage>,
    app: &AppHandle,
    msg: SignalMessage,
) -> Result<()> {
    match msg {
        SignalMessage::RoomJoined { room_id, peers, is_host, locked } => {
            tracing::info!("Joined room {room_id} with existing peers: {peers:?}, is_host: {is_host}, locked: {locked}");

            // Store host/locked state
            {
                let mut guard = engine.lock().await;
                if let Some(inner) = guard.as_mut() {
                    inner.is_host = is_host;
                    inner.room_locked = locked;
                }
            }

            // Emit peer-joined for each existing peer so frontend builds its peer list
            for peer_info in &peers {
                let _ = app.emit(EVENT_PEER_JOINED, peer_info);
            }

            // We are the new joiner — send offers to all existing peers
            for peer_info in &peers {
                let peer = create_peer_conn(engine, peer_info.peer_id.clone()).await?;

                let sdp = peer.create_offer().await?;
                signal_tx
                    .send(SignalMessage::Signal {
                        to: Some(peer_info.peer_id.clone()),
                        from: None,
                        payload: SignalPayload::Offer { sdp },
                    })
                    .map_err(|_| anyhow::anyhow!("Signal channel closed"))?;
            }

            // Update state with peer count
            let guard = engine.lock().await;
            if let Some(inner) = guard.as_ref() {
                let _ = app.emit(
                    EVENT_STATE_CHANGED,
                    CallState::InRoom {
                        room_id: inner.room_id.clone(),
                        room_name: inner.room_name.clone(),
                        is_host: inner.is_host,
                        locked: inner.room_locked,
                    },
                );
            }
        }

        SignalMessage::PeerJoined { peer_id, name, is_host } => {
            tracing::info!("Peer {peer_id} ({name}) joined — waiting for their offer");
            let _ = app.emit(EVENT_PEER_JOINED, PeerInfo { peer_id: peer_id.clone(), name, is_host });

            let guard = engine.lock().await;
            if let Some(inner) = guard.as_ref() {
                let _ = app.emit(
                    EVENT_STATE_CHANGED,
                    CallState::InRoom {
                        room_id: inner.room_id.clone(),
                        room_name: inner.room_name.clone(),
                        is_host: inner.is_host,
                        locked: inner.room_locked,
                    },
                );
            }
        }

        SignalMessage::PeerLeft { peer_id } => {
            tracing::info!("Peer {peer_id} left");
            let _ = app.emit(EVENT_PEER_LEFT, &peer_id);

            let mut guard = engine.lock().await;
            if let Some(inner) = guard.as_mut() {
                if let Some(peer) = inner.peers.remove(&peer_id) {
                    peer.close().await;
                }

                let _ = app.emit(
                    EVENT_STATE_CHANGED,
                    CallState::InRoom {
                        room_id: inner.room_id.clone(),
                        room_name: inner.room_name.clone(),
                        is_host: inner.is_host,
                        locked: inner.room_locked,
                    },
                );
            }
        }

        SignalMessage::Kicked => {
            tracing::info!("We were kicked from the room");

            // Clean up all peers
            let mut guard = engine.lock().await;
            if let Some(inner) = guard.take() {
                for (_, peer) in &inner.peers {
                    peer.close().await;
                }
            }

            let _ = app.emit(EVENT_STATE_CHANGED, CallState::Idle);
            let _ = app.emit(EVENT_KICKED, ());
        }

        SignalMessage::ForceMuted => {
            tracing::info!("We were force-muted by the host");

            let guard = engine.lock().await;
            if let Some(inner) = guard.as_ref() {
                inner.capture.set_muted(true);
            }

            let _ = app.emit(EVENT_FORCE_MUTED, ());
        }

        SignalMessage::RoomLocked { locked } => {
            tracing::info!("Room locked state changed: {locked}");

            let mut guard = engine.lock().await;
            if let Some(inner) = guard.as_mut() {
                inner.room_locked = locked;

                let _ = app.emit(
                    EVENT_ROOM_LOCKED,
                    locked,
                );

                let _ = app.emit(
                    EVENT_STATE_CHANGED,
                    CallState::InRoom {
                        room_id: inner.room_id.clone(),
                        room_name: inner.room_name.clone(),
                        is_host: inner.is_host,
                        locked: inner.room_locked,
                    },
                );
            }
        }

        SignalMessage::RoomLockedError => {
            tracing::info!("Room is password-protected, cannot join");

            // Clean up — we connected to signaling but were rejected
            let mut guard = engine.lock().await;
            if let Some(inner) = guard.take() {
                for (_, peer) in &inner.peers {
                    peer.close().await;
                }
            }

            let _ = app.emit(
                EVENT_STATE_CHANGED,
                CallState::Error {
                    message: "Room is password-protected".to_string(),
                },
            );
        }

        SignalMessage::RoomNotFound => {
            tracing::info!("Room does not exist");

            let mut guard = engine.lock().await;
            if let Some(inner) = guard.take() {
                for (_, peer) in &inner.peers {
                    peer.close().await;
                }
            }

            let _ = app.emit(
                EVENT_STATE_CHANGED,
                CallState::Error {
                    message: "Room not found".to_string(),
                },
            );
        }

        SignalMessage::PeerMuteState { peer_id, muted } => {
            tracing::info!("Peer {peer_id} mute state changed: {muted}");
            let _ = app.emit(EVENT_PEER_MUTE_CHANGED, PeerMuteEvent { peer_id, muted });
        }

        SignalMessage::Signal { from: Some(from), payload, .. } => {
            handle_signal_payload(engine, signal_tx, &from, payload).await?;
        }

        // Client-originating messages or unrecognized
        _ => {}
    }

    Ok(())
}

async fn handle_signal_payload(
    engine: &Arc<Mutex<Option<EngineInner>>>,
    signal_tx: &flume::Sender<SignalMessage>,
    from: &str,
    payload: SignalPayload,
) -> Result<()> {
    match payload {
        SignalPayload::Offer { sdp } => {
            tracing::info!("Received offer from {from}");

            // Create peer conn if we don't have one yet
            let peer = {
                let guard = engine.lock().await;
                let inner = guard.as_ref().context("Engine not active")?;
                inner.peers.get(from).cloned()
            };

            let peer = if let Some(p) = peer {
                p
            } else {
                create_peer_conn(engine, from.to_string()).await?
            };

            let answer_sdp = peer.handle_offer(&sdp).await?;

            signal_tx
                .send(SignalMessage::Signal {
                    to: Some(from.to_string()),
                    from: None,
                    payload: SignalPayload::Answer { sdp: answer_sdp },
                })
                .map_err(|_| anyhow::anyhow!("Signal channel closed"))?;
        }

        SignalPayload::Answer { sdp } => {
            tracing::info!("Received answer from {from}");
            let guard = engine.lock().await;
            let inner = guard.as_ref().context("Engine not active")?;
            if let Some(peer) = inner.peers.get(from) {
                peer.handle_answer(&sdp).await?;
            }
        }

        SignalPayload::IceCandidate {
            candidate,
            sdp_mid,
            sdp_mline_index,
        } => {
            let guard = engine.lock().await;
            let inner = guard.as_ref().context("Engine not active")?;
            if let Some(peer) = inner.peers.get(from) {
                peer.add_ice_candidate(&candidate, sdp_mid, sdp_mline_index)
                    .await?;
            }
        }
    }

    Ok(())
}

/// Create a new PeerConn, store it in the engine, and return a reference.
async fn create_peer_conn(
    engine: &Arc<Mutex<Option<EngineInner>>>,
    remote_peer_id: String,
) -> Result<Arc<PeerConn>> {
    let ice_tx = {
        let guard = engine.lock().await;
        let inner = guard.as_ref().context("Engine not active")?;
        inner.ice_tx.clone()
    };

    let peer = Arc::new(PeerConn::new(remote_peer_id.clone(), ice_tx).await?);

    {
        let mut guard = engine.lock().await;
        let inner = guard.as_mut().context("Engine not active")?;
        inner.peers.insert(remote_peer_id, Arc::clone(&peer));
    }

    Ok(peer)
}
